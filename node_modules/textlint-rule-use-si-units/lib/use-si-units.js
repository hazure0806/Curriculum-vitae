// use-si-unit.js
'use strict';

var _matchIndex = require("match-index");

var _nodeUtil = require("./util/node-util");

var P = require('parsimmon');

var numberWithUnitTarget = /[0-9]+? ([a-zA-ZΩΩ℧%‰‱℃℉ℊÅμ°′″^\-\/·･・\(\)]+)/;
var defaultOptions = {
  allowedUnits: [],
  restrictNonSIUnits: false
};
var siUnitOneChar = P.oneOf('-msAKg');
var siUnitManyChar = P.regexp(/mol|cd/);
var allowWordManyChar = P.regexp(/and|or|nor|but|by|for|from|on|out|per|to/);
var siDerivedUnitOneChar = P.oneOf('JWCVFΩSTH℃');
var siDerivedUnitManyChar = P.regexp(/rad|sr|Hz|N|Pa|Wb|lm|lx|Bq|Gy|Sv|kat/);
var nonSiUnitOneChar = P.oneOf('hd°′″lLtB');
var nonSiUnitManyChar = P.regexp(/min|au|ha|Da|eV|Np|dB/);
var siPrefixOneChar = P.oneOf('YZEPTGMkhcdmμnpfazy');
var siPrefixManyChar = P.string('da');
var concatSymbol = P.oneOf('^/·･・()');

var generateSiUnitParser = (allowedUnits, restrictNonSIUnits) => {
  // Combine parsers. The longer patterns must come first to avoid confusing patterns with the same prefix.
  var siUnitsManyChar = P.alt(siUnitManyChar, siDerivedUnitManyChar);
  var siUnitsOneChar = P.alt(siUnitOneChar, siDerivedUnitOneChar);

  if (restrictNonSIUnits !== true) {
    siUnitsManyChar = P.alt(siUnitsManyChar, nonSiUnitManyChar);
    siUnitsOneChar = P.alt(siUnitsOneChar, nonSiUnitOneChar);
  }

  if (allowedUnits.length > 0) {
    var allowedUnitsString = allowedUnits.reduce((prev, value) => prev === '' ? value : "".concat(prev, "|").concat(value), '');
    siUnitsManyChar = P.alt(siUnitsManyChar, P.regexp(new RegExp(allowedUnitsString)));
  }

  var siUnits = P.alt(siUnitsManyChar, allowWordManyChar, siUnitsOneChar);
  var siSymbols = P.alt(siPrefixManyChar, siPrefixOneChar, concatSymbol); // Construct an overall parser.

  return P.alt(siUnits, siSymbols, P.digit).many().assert(results => results.reduce((prev, value) => prev || siUnits.parse(value).status, false), 'Must contain at least one unit symbols');
};

module.exports = function (context) {
  var userOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = Object.assign({}, defaultOptions, userOptions);
  var {
    Syntax,
    RuleError,
    report,
    getSource
  } = context;
  return {
    [Syntax.Str](node) {
      if (!(0, _nodeUtil.isUserWrittenNode)(node, context)) {
        return;
      }

      var matches = (0, _matchIndex.matchCaptureGroupAll)(getSource(node), numberWithUnitTarget);
      matches.forEach(match => {
        var siUnitParser = generateSiUnitParser(options.allowedUnits, options.restrictNonSIUnits);
        var parseResult = siUnitParser.parse(match.text);
        var isSymbolOnly = concatSymbol.parse(match.text);
        if (parseResult.status === false && isSymbolOnly.status === false) report(node, new RuleError("\u300C".concat(match.text, "\u300D\u306B\u306F\u3001SI\u5358\u4F4D\u7CFB\u3067\u4F7F\u7528\u3067\u304D\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002SI\u5358\u4F4D\u7CFB\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002"), {
          index: match.index
        }));
      });
    }

  };
};
//# sourceMappingURL=use-si-units.js.map